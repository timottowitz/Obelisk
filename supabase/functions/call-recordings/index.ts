// Follow this setup guide to integrate the Deno language server with your editor:
// https://deno.land/manual/getting_started/setup_your_environment
// This enables autocomplete, go to definition, etc.

// Setup type definitions for built-in Supabase Runtime APIs
import "jsr:@supabase/functions-js/edge-runtime.d.ts";

import { Hono } from "jsr:@hono/hono";
import { cors } from "jsr:@hono/hono/cors";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.51.0";
import { extractUserAndOrgId } from "../_shared/index.ts";
import { GoogleCloudStorageService } from "../_shared/google-storage.ts";
import {
  GoogleGenAI,
  createUserContent,
  createPartFromUri,
  FileState,
} from "https://esm.sh/@google/genai@1.9.0";

console.log("Hello from Functions!");

const app = new Hono();

// Helper to format duration
function formatDuration(milliseconds: number): string {
  if (!milliseconds) return "0s";
  const totalSeconds = Math.floor(milliseconds / 1000);
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  const seconds = totalSeconds % 60;
  if (hours > 0) {
    return `${hours}h ${minutes}m`;
  } else if (minutes > 0) {
    return `${minutes}min`;
  } else {
    return `${seconds}s`;
  }
}

// Helper to generate markdown report
function generateMarkdownReport(
  recording: any,
  transcript: string,
  analysis: any
): string {
  const formatDate = (isoString: string) => {
    const date = new Date(isoString);
    return date.toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
  };

  const formatDuration = (milliseconds: number) => {
    const totalSeconds = Math.floor(milliseconds / 1000);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;

    if (hours > 0) {
      return `${hours}h ${minutes}m ${seconds}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds}s`;
    } else {
      return `${seconds}s`;
    }
  };

  return `# Legal Meeting Analysis Report

## ðŸ“‹ Meeting Information
- **Meeting ID**: ${recording.id}
- **Title**: ${recording.title}
- **Date & Time**: ${formatDate(recording.start_time)}
- **Duration**: ${formatDuration(recording.duration)}
- **Participants**: ${recording.participants?.join(", ") || "Not specified"}

## ðŸŽ¯ Executive Summary
${analysis.summary || "No summary available"}

## ðŸ“Š Meeting Metrics
- **Sentiment**: ${
    analysis.sentiment
      ? analysis.sentiment.charAt(0).toUpperCase() + analysis.sentiment.slice(1)
      : "N/A"
  }
- **Word Count**: ${recording.word_count || 0}
- **Action Items**: ${analysis.actionItems?.length || 0}
- **Decisions Made**: ${analysis.decisions?.length || 0}
- **Risk Items**: ${analysis.risks?.length || 0}

## ðŸ”‘ Key Points
${
  analysis.keyPoints?.length > 0
    ? analysis.keyPoints
        .map((point: string, i: number) => `${i + 1}. ${point}`)
        .join("\n")
    : "No key points identified"
}

## âœ… Action Items
${
  analysis.actionItems?.length > 0
    ? analysis.actionItems
        .map((item: any) => {
          const assignee = item.assignee
            ? ` - Assigned to: ${item.assignee}`
            : "";
          const dueDate = item.dueDate ? ` - Due: ${item.dueDate}` : "";
          return `- [ ] ${item.task || item}${assignee}${dueDate}`;
        })
        .join("\n")
    : "No action items identified"
}

## ðŸŽ¯ Decisions Made
${
  analysis.decisions?.length > 0
    ? analysis.decisions
        .map((decision: string, i: number) => `${i + 1}. ${decision}`)
        .join("\n")
    : "No decisions recorded"
}

## âš ï¸ Risk Analysis
${
  analysis.risks?.length > 0
    ? analysis.risks
        .map((risk: any) => {
          return `### ${risk.risk || risk}
- **Severity**: ${risk.severity || "Medium"}
- **Mitigation**: ${risk.mitigation || "To be determined"}`;
        })
        .join("\n\n")
    : "No significant risks identified"
}

## ðŸ“‹ Compliance Notes
${
  analysis.compliance?.length > 0
    ? analysis.compliance.map((note: string) => `- ${note}`).join("\n")
    : "No compliance notes"
}

## ðŸ“Œ Follow-up Tasks
${
  analysis.followUp?.length > 0
    ? analysis.followUp.map((task: string) => `- [ ] ${task}`).join("\n")
    : "No follow-up tasks identified"
}

## ðŸ·ï¸ Topics Discussed
${
  analysis.topics?.length > 0
    ? analysis.topics.map((topic: string) => `- ${topic}`).join("\n")
    : "Topics not identified"
}

## ðŸ“ Full Transcript

${transcript || "Transcript not available"}

---

*Generated by Call Caps AI Legal Analysis System*  
*Powered by OpenAI Whisper & GPT-4*  
*Generated on: ${new Date().toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  })}*

**Confidentiality Notice**: This document contains attorney-client privileged information and is strictly confidential.
`;
}

// Configure CORS with proper options handling
app.use(
  "*",
  cors({
    origin: "*",
    allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowHeaders: ["Content-Type", "Authorization", "X-Org-Id", "X-User-Id"],
    credentials: true,
  })
);

app.use("/call-recordings", extractUserAndOrgId);
app.use("/call-recordings/:id/process", extractUserAndOrgId);
app.use("/call-recordings/:id/video", extractUserAndOrgId);
app.use("/call-recordings/:id/share", extractUserAndOrgId);
app.use("/call-recordings/:id/shares", extractUserAndOrgId);
app.use("/call-recordings/upload", extractUserAndOrgId);
app.use("/call-recordings/organization-members", extractUserAndOrgId);
app.use("/call-recordings/accessible", extractUserAndOrgId);

app.options("*", (c) => {
  return c.text("", 200);
});

app.get("/call-recordings", async (c) => {
  const orgId = c.get("orgId");
  const userId = c.get("userId");

  try {
    const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";
    const supabase = createClient(supabaseUrl, supabaseServiceKey, {
      auth: { persistSession: false },
    });

    const org = await supabase
      .schema("private")
      .from("organizations")
      .select("*")
      .eq("clerk_organization_id", orgId)
      .single();
    if (org.error) {
      console.log(org);
      return c.json({ error: "Organization not found" }, 404);
    }
    const schema = org.data?.schema_name.toLowerCase();
    if (!schema) {
      return c.json({ error: "Organization not found" }, 404);
    }

    const user = await supabase
      .schema("private")
      .from("users")
      .select("*")
      .eq("clerk_user_id", userId)
      .single();
    if (user.error) {
      return c.json({ error: "User not found" }, 404);
    }
    const member = await supabase
      .schema("private")
      .from("organization_members")
      .select("*")
      .eq("user_id", user.data?.id)
      .eq("organization_id", org.data?.id)
      .single();
    if (member.error) {
      return c.json({ error: "Member not found" }, 404);
    }

    // Parse query params
    const url = new URL(c.req.url);
    const limit = parseInt(url.searchParams.get("limit") || "20");
    const offset = parseInt(url.searchParams.get("offset") || "0");
    const orderBy = url.searchParams.get("orderBy") || "start_time";
    const orderDirection = (url.searchParams.get("orderDirection") ||
      "desc") as "asc" | "desc";
    const search = url.searchParams.get("search") || undefined;
    const status = url.searchParams.get("status") || undefined;
    const startDate = url.searchParams.get("startDate") || undefined;
    const endDate = url.searchParams.get("endDate") || undefined;

    const pathParts = url.pathname.split("/");
    const recordingId = pathParts[pathParts.length - 1];
    const table = `call_recordings`;

    if (recordingId && recordingId !== "call-recordings") {
      const { data: recording, error } = await supabase
        .schema(schema)
        .from("accessible_recordings")
        .select("*")
        .eq("id", recordingId)
        .or(
          `member_id.eq.${member.data?.id},shared_with_member_id.eq.${member.data?.id}`
        )
        .single();
      if (error || !recording) {
        return c.json({ error: "Recording not found" }, 404);
      }
      return c.json({ recording }, 200);
    }

    // Query to get both owned and shared recordings
    let query = supabase
      .schema(schema)
      .from("accessible_recordings")
      .select("*", { count: "exact" })
      .or(
        `member_id.eq.${member.data?.id},shared_with_member_id.eq.${member.data?.id}`
      );
    if (search) {
      query = query.or(`title.ilike.%${search}%,participants.cs.{${search}}`);
    }
    if (status) {
      query = query.eq("status", status);
    }
    if (startDate) {
      query = query.gte("start_time", startDate);
    }
    if (endDate) {
      query = query.lte("start_time", endDate);
    }
    query = query.order(orderBy, { ascending: orderDirection === "asc" });
    query = query.range(offset, offset + limit - 1);
    const { data: recordings, error, count } = await query;
    if (error) {
      return c.json(
        { error: "Failed to fetch recordings", details: error },
        500
      );
    }
    const formattedRecordings = (recordings || []).map((recording: any) => ({
      ...recording,
      date: new Date(recording.start_time).toLocaleDateString("en-US", {
        weekday: "long",
        month: "long",
        day: "numeric",
      }),
      time: new Date(recording.start_time).toLocaleTimeString("en-US", {
        hour: "numeric",
        minute: "2-digit",
      }),
      duration: formatDuration(recording.duration),
      transcript: recording.ai_analysis
        ? {
            summary: recording.ai_summary,
            actionItems: recording.action_items || [],
            keyTopics: recording.key_topics || [],
            sentiment: recording.sentiment,
            wordCount: recording.word_count,
          }
        : null,
    }));
    return c.json(
      {
        recordings: formattedRecordings,
        total: count || 0,
        limit,
        offset,
      },
      200
    );
  } catch (error: any) {
    return c.json({ error: error.message }, 500);
  }
});

// Upload recording route
app.post("/call-recordings", async (c) => {
  const orgId = c.get("orgId");
  const userId = c.get("userId");

  try {
    const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";
    const supabase = createClient(supabaseUrl, supabaseServiceKey, {
      auth: { persistSession: false },
    });

    const org = await supabase
      .schema("private")
      .from("organizations")
      .select("*")
      .eq("clerk_organization_id", orgId)
      .single();
    if (org.error) {
      console.log(org);
      return c.json({ error: "Organization not found" }, 404);
    }
    const schema = org.data?.schema_name.toLowerCase();
    if (!schema) {
      return c.json({ error: "Organization not found" }, 404);
    }

    const user = await supabase
      .schema("private")
      .from("users")
      .select("*")
      .eq("clerk_user_id", userId)
      .single();
    if (user.error) {
      return c.json({ error: "User not found" }, 404);
    }
    const member = await supabase
      .schema("private")
      .from("organization_members")
      .select("*")
      .eq("user_id", user.data?.id)
      .eq("organization_id", org.data?.id)
      .single();
    if (member.error) {
      return c.json({ error: "Member not found" }, 404);
    }

    // Parse request body
    const body = await c.req.json();
    const {
      recordingBlob,
      mimeType,
      duration,
      startTime,
      endTime,
      title,
      participants,
    } = body;

    if (!recordingBlob || !mimeType || !duration || !startTime || !title) {
      return c.json(
        {
          error:
            "Missing required fields: recordingBlob, mimeType, duration, startTime, title",
        },
        400
      );
    }

    const recordingsTable = `call_recordings`;
    const queueTable = `processing_queue`;

    // Create recording record in database
    const { data: recording, error: insertError } = await supabase
      .schema(schema)
      .from(recordingsTable)
      .insert({
        member_id: member.data?.id,
        title,
        start_time: startTime,
        end_time: endTime,
        duration,
        participants: participants || [],
        mime_type: mimeType,
        status: "uploading",
        has_video: true,
        has_audio: true,
      })
      .select()
      .single();

    if (insertError || !recording) {
      console.log("insertError", insertError);
      return c.json(
        { error: "Failed to create recording record", details: insertError },
        500
      );
    }

    try {
      // Initialize Azure Blob Storage
      const gcsService = getGcsService();

      // Convert base64 to ArrayBuffer
      const binaryString = atob(recordingBlob);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }

      // Upload to Azure Blob Storage
      const uploadResult = await gcsService.uploadVideo(
        user.data?.id,
        recording.id,
        bytes,
        mimeType
      );

      // Update recording with Azure URLs
      const { error: updateError } = await supabase
        .schema(schema)
        .from(recordingsTable)
        .update({
          gcs_video_url: uploadResult.blobUrl,
          gcs_video_blob_name: uploadResult.blobName,
          file_size: bytes.length,
          status: "uploaded",
        })
        .eq("id", recording.id);

      if (updateError) {
        console.error(
          "Failed to update recording with Azure URLs:",
          updateError
        );
      }

      // Add to processing queue for transcription
      const { error: queueError } = await supabase
        .schema(schema)
        .from(queueTable)
        .insert({
          recording_id: recording.id,
          task_type: "transcribe",
          status: "pending",
        });

      if (queueError) {
        console.error("Failed to add to processing queue:", queueError);
      }

      return c.json(
        {
          success: true,
          recording: {
            id: recording.id,
            title: recording.title,
            status: "uploaded",
            gcs_video_url: uploadResult.blobUrl,
            duration: recording.duration,
            start_time: recording.start_time,
            end_time: recording.end_time,
          },
        },
        200
      );
    } catch (uploadError: any) {
      console.log("uploadError", uploadError);
      // Update recording status to failed
      await supabase
        .schema(schema)
        .from(recordingsTable)
        .update({
          status: "failed",
          processing_error: uploadError.message,
        })
        .eq("id", recording.id);

      return c.json(
        { error: "Failed to upload to Azure", details: uploadError.message },
        500
      );
    }
  } catch (error: any) {
    return c.json({ error: error.message }, 500);
  }
});

// Upload recording route with multipart form data
app.post("/call-recordings/upload", async (c) => {
  const orgId = c.get("orgId");
  const userId = c.get("userId");

  try {
    const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";
    const supabase = createClient(supabaseUrl, supabaseServiceKey, {
      auth: { persistSession: false },
    });

    const org = await supabase
      .schema("private")
      .from("organizations")
      .select("*")
      .eq("clerk_organization_id", orgId)
      .single();
    if (org.error) {
      console.log(org);
      return c.json({ error: "Organization not found" }, 404);
    }
    const schema = org.data?.schema_name.toLowerCase();
    if (!schema) {
      return c.json({ error: "Organization not found" }, 404);
    }

    const user = await supabase
      .schema("private")
      .from("users")
      .select("*")
      .eq("clerk_user_id", userId)
      .single();
    if (user.error) {
      return c.json({ error: "User not found" }, 404);
    }
    const member = await supabase
      .schema("private")
      .from("organization_members")
      .select("*")
      .eq("user_id", user.data?.id)
      .eq("organization_id", org.data?.id)
      .single();
    if (member.error) {
      return c.json({ error: "Member not found" }, 404);
    }

    // Parse multipart form data
    const formData = await c.req.formData();
    const file = formData.get("file") as File;
    const metadataString = formData.get("metadata") as string;

    if (!file || !metadataString) {
      return c.json(
        {
          error: "Missing required fields: file and metadata",
        },
        400
      );
    }

    let metadata;
    try {
      metadata = JSON.parse(metadataString);
    } catch (parseError) {
      return c.json(
        {
          error: "Invalid metadata JSON format",
        },
        400
      );
    }

    const { mimeType, duration, startTime, endTime, title, participants } =
      metadata;

    if (!mimeType || !duration || !startTime || !title) {
      return c.json(
        {
          error:
            "Missing required metadata fields: mimeType, duration, startTime, title",
        },
        400
      );
    }

    const recordingsTable = `call_recordings`;
    const settingsTable = `user_settings`;
    const queueTable = `processing_queue`;

    // Create recording record in database
    const { data: recording, error: insertError } = await supabase
      .schema(schema)
      .from(recordingsTable)
      .insert({
        member_id: member.data?.id,
        title,
        start_time: startTime,
        end_time: endTime,
        duration,
        participants: participants || [],
        mime_type: mimeType,
        status: "uploading",
        has_video: true,
        has_audio: true,
      })
      .select()
      .single();

    if (insertError || !recording) {
      console.log("insertError", insertError);
      return c.json(
        { error: "Failed to create recording record", details: insertError },
        500
      );
    }

    try {
      // Initialize Azure Blob Storage
      const gcsService = getGcsService();

      // Convert File to ArrayBuffer
      const fileArrayBuffer = await file.arrayBuffer();
      const bytes = new Uint8Array(fileArrayBuffer);

      // Upload to Azure Blob Storage
      const uploadResult = await gcsService.uploadVideo(
        user.data?.id,
        recording.id,
        bytes,
        mimeType
      );

      // Update recording with Azure URLs
      const { error: updateError } = await supabase
        .schema(schema)
        .from(recordingsTable)
        .update({
          gcs_video_url: uploadResult.blobUrl,
          gcs_video_blob_name: uploadResult.blobName,
          file_size: bytes.length,
          status: "uploaded",
        })
        .eq("id", recording.id);

      if (updateError) {
        console.error(
          "Failed to update recording with Azure URLs:",
          updateError
        );
      }

      // Add to processing queue for transcription
      const { error: queueError } = await supabase
        .schema(schema)
        .from(queueTable)
        .insert({
          recording_id: recording.id,
          task_type: "transcribe",
          status: "pending",
        });

      if (queueError) {
        console.error("Failed to add to processing queue:", queueError);
      }

      return c.json(
        {
          success: true,
          recording: {
            id: recording.id,
            title: recording.title,
            status: "uploaded",
            gcs_video_url: uploadResult.blobUrl,
            duration: recording.duration,
            start_time: recording.start_time,
            end_time: recording.end_time,
          },
        },
        200
      );
    } catch (uploadError: any) {
      console.log("uploadError", uploadError);
      // Update recording status to failed
      await supabase
        .schema(schema)
        .from(recordingsTable)
        .update({
          status: "failed",
          processing_error: uploadError.message,
        })
        .eq("id", recording.id);

      return c.json(
        { error: "Failed to upload to Azure", details: uploadError.message },
        500
      );
    }
  } catch (error: any) {
    return c.json({ error: error.message }, 500);
  }
});

// Process recording route
app.post("/call-recordings/:id/process", async (c) => {
  const orgId = c.get("orgId");
  const userId = c.get("userId");
  console.log("orgId", orgId);
  console.log("userId", userId);

  try {
    const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";
    const supabase = createClient(supabaseUrl, supabaseServiceKey, {
      auth: { persistSession: false },
    });

    const org = await supabase
      .schema("private")
      .from("organizations")
      .select("*")
      .eq("clerk_organization_id", orgId)
      .single();
    if (org.error) {
      return c.json({ error: "Organization not found" }, 404);
    }
    const schema = org.data?.schema_name.toLowerCase();
    if (!schema) {
      return c.json({ error: "Organization not found" }, 404);
    }

    const user = await supabase
      .schema("private")
      .from("users")
      .select("*")
      .eq("clerk_user_id", userId)
      .single();
    if (user.error) {
      return c.json({ error: "User not found" }, 404);
    }
    const member = await supabase
      .schema("private")
      .from("organization_members")
      .select("*")
      .eq("user_id", user.data?.id)
      .eq("organization_id", org.data?.id)
      .single();
    if (member.error) {
      return c.json({ error: "Member not found" }, 404);
    }

    // Get recording ID from URL
    const url = new URL(c.req.url);
    const pathParts = url.pathname.split("/");
    const recordingId = pathParts[pathParts.length - 2]; // /call-recordings/:id/process
    if (!recordingId || recordingId === "call-recordings") {
      return c.json({ error: "Recording ID required" }, 400);
    }

    // Parse request body
    const body = await c.req.json();
    const { taskType = "all" } = body;

    const recordingsTable = `call_recordings`;
    const settingsTable = `user_settings`;
    const queueTable = `processing_queue`;

    // Get recording details
    const { data: recording, error: recordingError } = await supabase
      .schema(schema)
      .from(recordingsTable)
      .select("*")
      .eq("id", recordingId)
      .eq("member_id", member.data?.id)
      .single();

    if (recordingError || !recording) {
      return c.json({ error: "Recording not found" }, 404);
    }

    // Get user settings for API keys, fallback to environment variables
    const { data: settings, error: settingsError } = await supabase
      .schema(schema)
      .from(settingsTable)
      .select("openai_api_key, ai_model, temperature, custom_prompts")
      .eq("member_id", member.data?.id)
      .single();

    // Use user settings if available, otherwise use environment variables
    let openaiApiKey = settings?.openai_api_key;

    if (!openaiApiKey) {
      openaiApiKey = Deno.env.get("OPENAI_API_KEY");
    }

    const googleApiKey = Deno.env.get("GOOGLE_API_KEY");

    if (!openaiApiKey) {
      return c.json(
        {
          error:
            "OpenAI API key not configured. Please add your API key in settings or configure OPENAI_API_KEY environment variable.",
        },
        400
      );
    }

    if (!googleApiKey) {
      return c.json(
        {
          error:
            "Google API key not configured. Please add your API key in settings or configure GOOGLE_API_KEY environment variable.",
        },
        400
      );
    }

    // Update recording status
    await supabase
      .schema(schema)
      .from(recordingsTable)
      .update({ status: "processing" })
      .eq("id", recordingId);

    try {
      let transcriptText = recording.transcript_text;
      let transcriptSegments = recording.transcript_segments;

      // Step 1: Transcribe if needed
      if (
        (taskType === "transcribe" || taskType === "all") &&
        !transcriptText
      ) {
        console.log("Starting transcription...");

        const gcsService = getGcsService();

        // Download video from Azure and prepare for Gemini upload
        const videoBytes = await gcsService.downloadBlob(
          recording.gcs_video_blob_name
        );

        // Convert bytes to Blob (supported in Deno)
        const videoBlob = new Blob([videoBytes], { type: recording.mime_type });

        const genAI = new GoogleGenAI({ apiKey: googleApiKey });

        // Upload the file to Gemini and use the returned File object directly
        let geminiFile = await genAI.files.upload({
          file: videoBlob,
          config: {
            mimeType: recording.mime_type,
            displayName: recording.gcs_video_blob_name,
          },
        });

        console.log("Gemini file state:", geminiFile.state);

        while (geminiFile.state !== FileState.ACTIVE) {
          geminiFile = await genAI.files.get({
            name: geminiFile.name ?? "",
          });
          console.log("Gemini file state:", geminiFile.state);
          if (geminiFile.state === FileState.FAILED) {
            throw new Error(
              `Failed to upload file to Gemini: ${geminiFile.error}`
            );
          }
          await new Promise((resolve) => setTimeout(resolve, 1000));
        }

        const prompt = `Generate audio diarization for this interview. Respond ONLY with a valid JSON array (not inside a markdown code block or with any extra text), where each item has the following shape:
{
  "speaker": "Speaker name or number (e.g., 'Speaker A', 'Speaker B', or a real name if you can infer it)",
  "transcription": "Utterance text"
}
Do not include any commentary, explanation, or markdown formatting. The output must be a valid JSON array that can be directly parsed as a JavaScript object.`;

        if (!geminiFile.uri || !geminiFile.mimeType) {
          throw new Error("Failed to upload file to Gemini");
        }

        // Call Gemini model directly via models.generateContent
        const genResponse = await genAI.models.generateContent({
          model: "gemini-1.5-flash",
          contents: createUserContent([
            prompt,
            createPartFromUri(geminiFile.uri, geminiFile.mimeType),
          ]),
        });

        const rawText = genResponse.text?.trim();
        console.log("Raw text:", rawText);

        // Gemini often returns JSON wrapped in markdown code blocks or with additional commentary.
        // Extract the JSON payload safely.
        let rawJsonText = rawText;
        if (rawJsonText?.startsWith("```")) {
          rawJsonText = rawJsonText.replace(/```json|```/gi, "").trim();
        }

        console.log("Raw JSON text:", rawJsonText);

        // Attempt to parse JSON. If it fails, try to locate the first JSON object/array in the text.
        let transcript;
        try {
          transcript = JSON.parse(rawJsonText ?? "");
        } catch (parseErr) {
          const jsonMatch = rawJsonText?.match(/[\[{].*[\]}]/s);
          if (jsonMatch) {
            transcript = JSON.parse(jsonMatch[0]);
          } else {
            throw new Error(
              `Failed to parse transcript JSON: ${
                (parseErr as Error)?.message
              }. Raw response: ${rawText ?? ""}`
            );
          }
        }

        console.log("Transcript:", transcript);

        transcriptText = transcript.map((t: any) => t.transcription).join("\n");
        transcriptSegments = transcript;

        // Update recording with transcript
        await supabase
          .schema(schema)
          .from(recordingsTable)
          .update({
            transcript_text: transcriptText,
            transcript_segments: transcriptSegments,
            word_count: transcriptText.split(/\s+/).length,
          })
          .eq("id", recordingId);
      }

      // Step 2: Analyze transcript if needed
      let analysis = recording.ai_analysis;
      if (
        (taskType === "analyze" || taskType === "all") &&
        transcriptText &&
        !analysis
      ) {
        console.log("Starting AI analysis...");

        const systemPrompt =
          settings?.custom_prompts?.analysis ||
          `You are an AI assistant that analyzes meeting recordings and call transcripts for legal professionals. 
        Provide a structured analysis including:
        1. Executive summary
        2. Key points and decisions
        3. Action items with clear ownership
        4. Risk analysis and compliance notes
        5. Follow-up tasks
        
        IMPORTANT: Return ONLY a valid JSON object. Do not wrap your response in markdown code blocks or any other formatting. Your response should start with { and end with }.
        
        Use exactly this JSON structure:
        {
          "summary": "Brief executive summary",
          "keyPoints": ["point 1", "point 2"],
          "actionItems": [{"task": "task description", "assignee": "person", "dueDate": "date"}],
          "decisions": ["decision 1", "decision 2"],
          "risks": [{"risk": "description", "severity": "high/medium/low", "mitigation": "steps"}],
          "compliance": ["note 1", "note 2"],
          "followUp": ["task 1", "task 2"],
          "sentiment": "positive|neutral|negative",
          "topics": ["topic 1", "topic 2"]
        }`;

        // Call OpenAI GPT for analysis
        const gptResponse = await fetch(
          "https://api.openai.com/v1/chat/completions",
          {
            method: "POST",
            headers: {
              Authorization: `Bearer ${Deno.env.get("OPENAI_API_KEY")}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              model: settings?.ai_model || "gpt-4o-mini",
              messages: [
                {
                  role: "system",
                  content: systemPrompt,
                },
                {
                  role: "user",
                  content: `Please analyze this legal meeting transcript:\n\n${transcriptText}`,
                },
              ],
              temperature: settings?.temperature || 0.3,
              max_tokens: 2000,
            }),
          }
        );

        if (!gptResponse.ok) {
          const error = await gptResponse.text();
          throw new Error(`GPT API error: ${error}`);
        }

        const gptResult = await gptResponse.json();
        const analysisText = gptResult.choices[0].message.content;

        try {
          analysis = JSON.parse(analysisText);
        } catch (parseError) {
          console.error("JSON parsing error:", parseError);
          console.error("Raw analysis text:", analysisText);

          // Fallback if JSON parsing fails
          analysis = {
            summary: analysisText,
            keyPoints: [],
            actionItems: [],
            decisions: [],
            risks: [],
            compliance: [],
            followUp: [],
            sentiment: "neutral",
            topics: [],
          };
        }

        // Update recording with analysis
        await supabase
          .schema(schema)
          .from(recordingsTable)
          .update({
            ai_analysis: analysis,
            ai_summary: analysis.summary,
            action_items: analysis.actionItems || [],
            key_topics: analysis.topics || [],
            sentiment: analysis.sentiment || "neutral",
            risk_analysis: analysis.risks || [],
          })
          .eq("id", recordingId);
      }

      // Step 3: Generate and upload markdown report
      if (transcriptText && analysis) {
        console.log("Generating markdown report...");

        const markdown = generateMarkdownReport(
          recording,
          transcriptText,
          analysis
        );

        // Initialize Azure Blob Storage
        const gcsService = getGcsService();

        // Upload markdown to Azure
        const transcriptResult = await gcsService.uploadTranscript(
          user.data?.id,
          recordingId,
          markdown
        );

        // Update recording with transcript URL
        await supabase
          .schema(schema)
          .from(recordingsTable)
          .update({
            gcs_transcript_url: transcriptResult.blobUrl,
            gcs_transcript_blob_name: transcriptResult.blobName,
            status: "processed",
            processed_at: new Date().toISOString(),
          })
          .eq("id", recordingId);
      }

      // Update processing queue
      await supabase
        .schema(schema)
        .from(queueTable)
        .update({
          status: "completed",
          completed_at: new Date().toISOString(),
        })
        .eq("recording_id", recordingId)
        .eq("task_type", taskType === "all" ? "transcribe" : taskType);

      return c.json(
        {
          success: true,
          recording: {
            id: recording.id,
            title: recording.title,
            status: "processed",
            transcript_text: transcriptText,
            ai_analysis: analysis,
            ai_summary: analysis?.summary,
          },
        },
        200
      );
    } catch (processingError: any) {
      console.error("Processing error:", processingError);

      // Update recording status to failed
      await supabase
        .schema(schema)
        .from(recordingsTable)
        .update({
          status: "failed",
          processing_error: processingError.message,
        })
        .eq("id", recordingId);

      // Update processing queue
      await supabase
        .schema(schema)
        .from(queueTable)
        .update({
          status: "failed",
          error_message: processingError.message,
          retry_count: (recording.retry_count || 0) + 1,
        })
        .eq("recording_id", recordingId);

      return c.json(
        { error: "Processing failed", details: processingError.message },
        500
      );
    }
  } catch (error: any) {
    return c.json({ error: error.message }, 500);
  }
});

// Video proxy endpoint to serve videos with proper CORS
app.get("/call-recordings/:id/video", async (c) => {
  const orgId = c.get("orgId");
  const userId = c.get("userId");
  const recordingId = c.req.param("id");

  try {
    const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";
    const supabase = createClient(supabaseUrl, supabaseServiceKey, {
      auth: { persistSession: false },
    });

    const org = await supabase
      .schema("private")
      .from("organizations")
      .select("*")
      .eq("clerk_organization_id", orgId)
      .single();
    if (org.error) {
      return c.json({ error: "Organization not found" }, 404);
    }
    const schema = org.data?.schema_name.toLowerCase();
    if (!schema) {
      return c.json({ error: "Organization not found" }, 404);
    }

    const user = await supabase
      .schema("private")
      .from("users")
      .select("*")
      .eq("clerk_user_id", userId)
      .single();
    if (user.error) {
      return c.json({ error: "User not found" }, 404);
    }
    const member = await supabase
      .schema("private")
      .from("organization_members")
      .select("*")
      .eq("user_id", user.data?.id)
      .eq("organization_id", org.data?.id)
      .single();
    if (member.error) {
      return c.json({ error: "Member not found" }, 404);
    }

    // Get recording details (including shared recordings)
    const { data: recording, error: recordingError } = await supabase
      .schema(schema)
      .from("accessible_recordings")
      .select("*")
      .eq("id", recordingId)
      .or(
        `member_id.eq.${member.data?.id},shared_with_member_id.eq.${member.data?.id}`
      )
      .single();

    if (recordingError || !recording) {
      return c.json({ error: "Recording not found" }, 404);
    }

    if (!recording.gcs_video_blob_name) {
      return c.json({ error: "Video file not found" }, 404);
    }

    const gcsService = getGcsService();

    // Download video from Azure
    const videoData = await gcsService.downloadBlob(
      recording.gcs_video_blob_name
    );

    // Return video with proper headers
    return new Response(videoData, {
      headers: {
        "Content-Type": recording.mime_type || "video/webm",
        "Accept-Ranges": "bytes",
        "Cache-Control": "public, max-age=3600",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, HEAD, OPTIONS",
        "Access-Control-Allow-Headers": "*",
      },
    });
  } catch (error: any) {
    console.error("Video proxy error:", error);
    return c.json({ error: "Failed to load video" }, 500);
  }
});

// Get organization members for sharing UI
app.get("/call-recordings/organization-members", async (c) => {
  const orgId = c.get("orgId");
  const userId = c.get("userId");

  try {
    const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";
    const supabase = createClient(supabaseUrl, supabaseServiceKey, {
      auth: { persistSession: false },
    });

    const org = await supabase
      .schema("private")
      .from("organizations")
      .select("*")
      .eq("clerk_organization_id", orgId)
      .single();
    if (org.error) {
      return c.json({ error: "Organization not found" }, 404);
    }

    const user = await supabase
      .schema("private")
      .from("users")
      .select("*")
      .eq("clerk_user_id", userId)
      .single();
    if (user.error) {
      return c.json({ error: "User not found" }, 404);
    }

    const member = await supabase
      .schema("private")
      .from("organization_members")
      .select("*")
      .eq("user_id", user.data?.id)
      .eq("organization_id", org.data?.id)
      .single();
    if (member.error) {
      return c.json({ error: "Member not found" }, 404);
    }

    // Get all organization members except the current user
    const { data: members, error: membersError } = await supabase
      .schema("private")
      .from("organization_members")
      .select(
        `
        id,
        role,
        status,
        joined_at,
        users:user_id (
          id,
          email,
          full_name
        )
      `
      )
      .eq("organization_id", org.data?.id)
      .eq("status", "active")
      .neq("id", member.data?.id);

    if (membersError) {
      return c.json(
        {
          error: "Failed to fetch organization members",
          details: membersError,
        },
        500
      );
    }

    const formattedMembers = members.map((member: any) => ({
      id: member.id,
      userId: member.users.id,
      email: member.users.email,
      fullName: member.users.full_name,
      role: member.role,
      status: member.status,
      joinedAt: member.joined_at,
    }));

    return c.json({ members: formattedMembers }, 200);
  } catch (error: any) {
    return c.json({ error: error.message }, 500);
  }
});

// Get all accessible recordings for current user (owned + shared)
app.get("/call-recordings/accessible", async (c) => {
  const orgId = c.get("orgId");
  const userId = c.get("userId");

  try {
    const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";
    const supabase = createClient(supabaseUrl, supabaseServiceKey, {
      auth: { persistSession: false },
    });

    const org = await supabase
      .schema("private")
      .from("organizations")
      .select("*")
      .eq("clerk_organization_id", orgId)
      .single();
    if (org.error) {
      return c.json({ error: "Organization not found" }, 404);
    }
    const schema = org.data?.schema_name.toLowerCase();
    if (!schema) {
      return c.json({ error: "Organization not found" }, 404);
    }

    const user = await supabase
      .schema("private")
      .from("users")
      .select("*")
      .eq("clerk_user_id", userId)
      .single();
    if (user.error) {
      return c.json({ error: "User not found" }, 404);
    }

    const member = await supabase
      .schema("private")
      .from("organization_members")
      .select("*")
      .eq("user_id", user.data?.id)
      .eq("organization_id", org.data?.id)
      .single();
    if (member.error) {
      return c.json({ error: "Member not found" }, 404);
    }

    // Parse query params for filtering and pagination
    const url = new URL(c.req.url);
    const limit = parseInt(url.searchParams.get("limit") || "50");
    const offset = parseInt(url.searchParams.get("offset") || "0");
    const orderBy = url.searchParams.get("orderBy") || "start_time";
    const orderDirection = (url.searchParams.get("orderDirection") ||
      "desc") as "asc" | "desc";
    const search = url.searchParams.get("search") || undefined;
    const status = url.searchParams.get("status") || undefined;
    const startDate = url.searchParams.get("startDate") || undefined;
    const endDate = url.searchParams.get("endDate") || undefined;
    const accessType = url.searchParams.get("accessType") || undefined; // 'owned', 'shared', or 'all'

    // Build the query to get accessible recordings
    let query = supabase
      .schema(schema)
      .from("accessible_recordings")
      .select("*", { count: "exact" });

    // Filter by access type
    if (accessType === "owned") {
      query = query.eq("member_id", member.data?.id);
    } else if (accessType === "shared") {
      query = query.eq("shared_with_member_id", member.data?.id);
    } else {
      // Default: get both owned and shared recordings
      query = query.or(
        `member_id.eq.${member.data?.id},shared_with_member_id.eq.${member.data?.id}`
      );
    }

    // Apply additional filters
    if (search) {
      query = query.or(`title.ilike.%${search}%,participants.cs.{${search}}`);
    }
    if (status) {
      query = query.eq("status", status);
    }
    if (startDate) {
      query = query.gte("start_time", startDate);
    }
    if (endDate) {
      query = query.lte("start_time", endDate);
    }

    // Apply ordering and pagination
    query = query.order(orderBy, { ascending: orderDirection === "asc" });
    query = query.range(offset, offset + limit - 1);

    const { data: recordings, error, count } = await query;

    if (error) {
      return c.json(
        { error: "Failed to fetch accessible recordings", details: error },
        500
      );
    }

    // Get unique shared_by_member_ids for batch lookup
    const sharedByMemberIds = [
      ...new Set(
        recordings
          ?.filter((r) => r.shared_by_member_id)
          .map((r) => r.shared_by_member_id)
      ),
    ];

    // Fetch member information for shared recordings
    let memberInfoMap: { [key: string]: any } = {};
    if (sharedByMemberIds.length > 0) {
      const { data: members } = await supabase
        .schema("private")
        .from("organization_members")
        .select(
          `
          id,
          users:user_id (
            full_name,
            email
          )
        `
        )
        .in("id", sharedByMemberIds);

      memberInfoMap = (members || []).reduce((acc: any, member: any) => {
        acc[member.id] = member;
        return acc;
      }, {});
    }

    // Format the recordings with additional metadata
    const formattedRecordings = (recordings || []).map((recording: any) => ({
      ...recording,
      date: new Date(recording.start_time).toLocaleDateString("en-US", {
        weekday: "long",
        month: "long",
        day: "numeric",
      }),
      time: new Date(recording.start_time).toLocaleTimeString("en-US", {
        hour: "numeric",
        minute: "2-digit",
      }),
      duration: formatDuration(recording.duration),
      // Add sharing metadata
      isOwned: recording.member_id === member.data?.id,
      isShared: recording.access_type === "shared",
      sharedBy:
        recording.shared_by_member_id &&
        memberInfoMap[recording.shared_by_member_id]
          ? {
              id: memberInfoMap[recording.shared_by_member_id].id,
              name: memberInfoMap[recording.shared_by_member_id].users
                .full_name,
              email: memberInfoMap[recording.shared_by_member_id].users.email,
            }
          : null,
      permissionLevel: recording.permission_level || "view",
      shareExpiresAt: recording.share_expires_at,
      transcript_text: recording.transcript_text,
      transcript_segments: recording.transcript_segments,
      // Include transcript data if available
      transcript: recording.ai_analysis
        ? {
            summary: recording.ai_summary,
            actionItems: recording.action_items || [],
            keyTopics: recording.key_topics || [],
            sentiment: recording.sentiment,
            wordCount: recording.word_count,
          }
        : null,
    }));

    // Group recordings by access type for easier consumption
    const ownedRecordings = formattedRecordings.filter((r) => r.isOwned);
    const sharedRecordings = formattedRecordings.filter((r) => r.isShared);

    return c.json(
      {
        recordings: formattedRecordings,
        summary: {
          total: count || 0,
          owned: ownedRecordings.length,
          shared: sharedRecordings.length,
        },
        pagination: {
          limit,
          offset,
          total: count || 0,
          hasMore: offset + limit < (count || 0),
        },
        filters: {
          orderBy,
          orderDirection,
          search,
          status,
          startDate,
          endDate,
          accessType,
        },
      },
      200
    );
  } catch (error: any) {
    return c.json({ error: error.message }, 500);
  }
});

// Share a recording with specific members
app.post("/call-recordings/:id/share", async (c) => {
  const orgId = c.get("orgId");
  const userId = c.get("userId");
  const recordingId = c.req.param("id");

  try {
    const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";
    const supabase = createClient(supabaseUrl, supabaseServiceKey, {
      auth: { persistSession: false },
    });

    const org = await supabase
      .schema("private")
      .from("organizations")
      .select("*")
      .eq("clerk_organization_id", orgId)
      .single();
    if (org.error) {
      return c.json({ error: "Organization not found" }, 404);
    }
    const schema = org.data?.schema_name.toLowerCase();

    const user = await supabase
      .schema("private")
      .from("users")
      .select("*")
      .eq("clerk_user_id", userId)
      .single();
    if (user.error) {
      return c.json({ error: "User not found" }, 404);
    }

    const member = await supabase
      .schema("private")
      .from("organization_members")
      .select("*")
      .eq("user_id", user.data?.id)
      .eq("organization_id", org.data?.id)
      .single();
    if (member.error) {
      return c.json({ error: "Member not found" }, 404);
    }

    // Parse request body
    const body = await c.req.json();
    const { memberIds, permissionLevel = "view", expiresAt } = body;

    if (!memberIds || !Array.isArray(memberIds) || memberIds.length === 0) {
      return c.json({ error: "Member IDs are required" }, 400);
    }

    // Verify recording exists and user owns it
    const { data: recording, error: recordingError } = await supabase
      .schema(schema)
      .from("call_recordings")
      .select("*")
      .eq("id", recordingId)
      .eq("member_id", member.data?.id)
      .single();

    if (recordingError || !recording) {
      return c.json({ error: "Recording not found or access denied" }, 404);
    }

    // Verify all member IDs belong to the same organization
    const { data: orgMembers, error: orgMembersError } = await supabase
      .schema("private")
      .from("organization_members")
      .select("id")
      .eq("organization_id", org.data?.id)
      .in("id", memberIds);

    if (orgMembersError || orgMembers.length !== memberIds.length) {
      return c.json({ error: "Invalid member IDs" }, 400);
    }

    // Create share records
    const shareRecords = memberIds.map((memberId: string) => ({
      recording_id: recordingId,
      shared_by_member_id: member.data?.id,
      shared_with_member_id: memberId,
      permission_level: permissionLevel,
      expires_at: expiresAt ? new Date(expiresAt).toISOString() : null,
    }));

    const { data: shares, error: sharesError } = await supabase
      .schema(schema)
      .from("recording_shares")
      .upsert(shareRecords, {
        onConflict: "recording_id,shared_with_member_id",
      })
      .select();

    if (sharesError) {
      return c.json(
        { error: "Failed to create shares", details: sharesError },
        500
      );
    }

    // Update recording to mark as shared
    await supabase
      .schema(schema)
      .from("call_recordings")
      .update({ is_shared: true })
      .eq("id", recordingId);

    return c.json(
      {
        success: true,
        message: `Recording shared with ${memberIds.length} member(s)`,
        shares: shares,
      },
      200
    );
  } catch (error: any) {
    return c.json({ error: error.message }, 500);
  }
});

// Get sharing information for a recording
app.get("/call-recordings/:id/shares", async (c) => {
  const orgId = c.get("orgId");
  const userId = c.get("userId");
  const recordingId = c.req.param("id");

  try {
    const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";
    const supabase = createClient(supabaseUrl, supabaseServiceKey, {
      auth: { persistSession: false },
    });

    const org = await supabase
      .schema("private")
      .from("organizations")
      .select("*")
      .eq("clerk_organization_id", orgId)
      .single();
    if (org.error) {
      return c.json({ error: "Organization not found" }, 404);
    }
    const schema = org.data?.schema_name.toLowerCase();

    const user = await supabase
      .schema("private")
      .from("users")
      .select("*")
      .eq("clerk_user_id", userId)
      .single();
    if (user.error) {
      return c.json({ error: "User not found" }, 404);
    }

    const member = await supabase
      .schema("private")
      .from("organization_members")
      .select("*")
      .eq("user_id", user.data?.id)
      .eq("organization_id", org.data?.id)
      .single();
    if (member.error) {
      return c.json({ error: "Member not found" }, 404);
    }

    // Verify recording exists and user has access (owner or shared with)
    const { data: recording, error: recordingError } = await supabase
      .schema(schema)
      .from("accessible_recordings")
      .select("*")
      .eq("id", recordingId)
      .or(
        `member_id.eq.${member.data?.id},shared_with_member_id.eq.${member.data?.id}`
      )
      .single();

    if (recordingError || !recording) {
      return c.json({ error: "Recording not found or access denied" }, 404);
    }

    // Get all shares for this recording
    const { data: shares, error: sharesError } = await supabase
      .schema(schema)
      .from("recording_shares")
      .select(
        `
        id,
        permission_level,
        expires_at,
        created_at,
        updated_at,
        shared_with_member:shared_with_member_id (
          id,
          role,
          users:user_id (
            email,
            full_name
          )
        ),
        shared_by_member:shared_by_member_id (
          id,
          role,
          users:user_id (
            email,
            full_name
          )
        )
      `
      )
      .eq("recording_id", recordingId)
      .or("expires_at.is.null,expires_at.gt.now()");

    if (sharesError) {
      return c.json(
        { error: "Failed to fetch shares", details: sharesError },
        500
      );
    }

    const formattedShares = shares.map((share: any) => ({
      id: share.id,
      permissionLevel: share.permission_level,
      expiresAt: share.expires_at,
      createdAt: share.created_at,
      updatedAt: share.updated_at,
      sharedWith: {
        id: share.shared_with_member.id,
        email: share.shared_with_member.users.email,
        fullName: share.shared_with_member.users.full_name,
        role: share.shared_with_member.role,
      },
      sharedBy: {
        id: share.shared_by_member.id,
        email: share.shared_by_member.users.email,
        fullName: share.shared_by_member.users.full_name,
        role: share.shared_by_member.role,
      },
    }));

    return c.json(
      {
        recordingId: recordingId,
        isOwner: recording.member_id === member.data?.id,
        shares: formattedShares,
      },
      200
    );
  } catch (error: any) {
    return c.json({ error: error.message }, 500);
  }
});

// Remove sharing for a recording
app.delete("/call-recordings/:id/share/:memberId", async (c) => {
  const orgId = c.get("orgId");
  const userId = c.get("userId");
  const recordingId = c.req.param("id");
  const sharedMemberId = c.req.param("memberId");

  try {
    const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";
    const supabase = createClient(supabaseUrl, supabaseServiceKey, {
      auth: { persistSession: false },
    });

    const org = await supabase
      .schema("private")
      .from("organizations")
      .select("*")
      .eq("clerk_organization_id", orgId)
      .single();
    if (org.error) {
      return c.json({ error: "Organization not found" }, 404);
    }
    const schema = org.data?.schema_name.toLowerCase();

    const user = await supabase
      .schema("private")
      .from("users")
      .select("*")
      .eq("clerk_user_id", userId)
      .single();
    if (user.error) {
      return c.json({ error: "User not found" }, 404);
    }

    const member = await supabase
      .schema("private")
      .from("organization_members")
      .select("*")
      .eq("user_id", user.data?.id)
      .eq("organization_id", org.data?.id)
      .single();
    if (member.error) {
      return c.json({ error: "Member not found" }, 404);
    }

    // Verify recording exists and user owns it
    const { data: recording, error: recordingError } = await supabase
      .schema(schema)
      .from("call_recordings")
      .select("*")
      .eq("id", recordingId)
      .eq("member_id", member.data?.id)
      .single();

    if (recordingError || !recording) {
      return c.json({ error: "Recording not found or access denied" }, 404);
    }

    // Remove the share
    const { error: deleteError } = await supabase
      .schema(schema)
      .from("recording_shares")
      .delete()
      .eq("recording_id", recordingId)
      .eq("shared_with_member_id", sharedMemberId);

    if (deleteError) {
      return c.json(
        { error: "Failed to remove share", details: deleteError },
        500
      );
    }

    // Check if there are any remaining shares
    const { data: remainingShares, error: remainingError } = await supabase
      .schema(schema)
      .from("recording_shares")
      .select("id")
      .eq("recording_id", recordingId)
      .limit(1);

    if (remainingError) {
      console.error("Error checking remaining shares:", remainingError);
    }

    // Update recording's is_shared status if no shares remain
    if (!remainingShares || remainingShares.length === 0) {
      await supabase
        .schema(schema)
        .from("call_recordings")
        .update({ is_shared: false })
        .eq("id", recordingId);
    }

    return c.json(
      {
        success: true,
        message: "Recording share removed successfully",
      },
      200
    );
  } catch (error: any) {
    return c.json({ error: error.message }, 500);
  }
});

// Place getGcsService at the top so it's in scope for all endpoints
function getGcsService() {
  const gcsKeyRaw = Deno.env.get("GCS_JSON_KEY");
  const bucketName = Deno.env.get("GCS_BUCKET_NAME");
  if (!gcsKeyRaw || !bucketName) {
    throw new Error(
      "GCS storage not configured. Please set GCS_JSON_KEY and GCS_BUCKET_NAME in environment variables."
    );
  }
  let credentials;
  try {
    credentials = JSON.parse(gcsKeyRaw);
  } catch (e: any) {
    throw new Error("Invalid GCS_JSON_KEY: " + (e?.message || e));
  }
  return new GoogleCloudStorageService({ bucketName, credentials });
}

export default app;

/* To invoke locally:

  1. Run `supabase start` (see: https://supabase.com/docs/reference/cli/supabase-start)
  2. Make an HTTP request:

  curl -i --location --request POST 'http://127.0.0.1:54321/functions/v1/call-recordings' \
    --header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZS1kZW1vIiwicm9sZSI6ImFub24iLCJleHAiOjE5ODM4MTI5OTZ9.CRXP1A7WOeoJeXxjNni43kdQwgnWNReilDMblYTn_I0' \
    --header 'Content-Type: application/json' \
    --data '{"name":"Functions"}'

*/
